<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Berlin Bar Tycoon - Optimized Territory</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Leaflet CSS & JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body { background-color: #1a1a1a; color: white; overflow: hidden; }
        #map { height: 100vh; width: 100vw; z-index: 0; }
        
        /* Map Marker Styles */
        .bar-marker-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .bar-marker {
            transition: all 0.3s ease;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            width: 30px;
            height: 30px;
            background-color: #333;
            z-index: 10;
        }
        
        .marker-locked { background-color: #ef4444; opacity: 0.8; }
        .marker-owned { background-color: #22c55e; border-color: #86efac; }
        .marker-affordable-base { background-color: #eab308; }

        .upgrade-arrow {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            color: #4ade80;
            font-size: 24px;
            font-weight: bold;
            animation: bounce 1s infinite;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            cursor: pointer;
            pointer-events: auto !important;
            filter: drop-shadow(0 0 2px black);
        }
        .upgrade-arrow:hover { transform: translateX(-50%) scale(1.2); color: #22c55e; }

        .income-badge {
            position: absolute;
            bottom: -18px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #4ade80;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 4px;
            white-space: nowrap;
            font-weight: bold;
            border: 1px solid #22c55e;
            z-index: 20;
            pointer-events: none;
        }

        .level-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background-color: #374151; /* Gray-700 */
            color: white;
            border: 1px solid white;
            border-radius: 50%;
            font-size: 9px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 25;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            transition: all 0.5s ease;
        }

        /* Persistent Level Tiers */
        .level-tier-1 { /* 5-9: Gold */
            background-color: #fbbf24; color: black; border-color: #f59e0b;
            box-shadow: 0 0 8px rgba(251, 191, 36, 0.6); animation: pulse-gold 3s infinite;
        }
        .level-tier-2 { /* 10-24: Cyan */
            background-color: #22d3ee; color: black; border-color: #06b6d4;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.6); animation: pulse-cyan 3s infinite;
        }
        .level-tier-3 { /* 25+: Purple */
            background-color: #d8b4fe; color: black; border-color: #a855f7;
            box-shadow: 0 0 12px rgba(168, 85, 247, 0.8); animation: pulse-purple 2s infinite;
        }

        @keyframes pulse-gold { 50% { box-shadow: 0 0 15px rgba(251, 191, 36, 0.4); } }
        @keyframes pulse-cyan { 50% { box-shadow: 0 0 15px rgba(34, 211, 238, 0.4); } }
        @keyframes pulse-purple { 50% { box-shadow: 0 0 20px rgba(168, 85, 247, 0.5); } }

        .float-text {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0,0,0,1);
            animation: floatUp 1s forwards;
            pointer-events: none;
            z-index: 200;
            white-space: nowrap;
        }

        .money-particle {
            position: absolute;
            color: #4ade80;
            font-weight: bold;
            font-size: 10px;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            animation: floatUpParticle 4s linear;
        }

        @keyframes floatUpParticle {
            0% { opacity: 0; transform: translateY(0) scale(0.5); }
            20% { opacity: 0.8; transform: translateY(-10px) scale(1); }
            80% { opacity: 0.8; }
            100% { opacity: 0; transform: translateY(-40px) scale(1.2); }
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateX(-50%) translateY(0); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-8px); }
        }

        @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
        .animate-slide-up { animation: slideUp 0.3s ease-out; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .animate-fade-in { animation: fadeIn 0.5s ease-out; }

        .confetti-piece {
            position: absolute; width: 10px; height: 10px; background: #ffd700; top: -10px;
            animation: confetti 3s linear forwards;
        }
        @keyframes confetti {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- MATH HELPERS ---
        const crossProduct = (o, a, b) => {
            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
        };

        const getConvexHull = (points) => {
            if (points.length <= 2) return points;
            const sorted = [...points].sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);
            const lower = [];
            for (let point of sorted) {
                while (lower.length >= 2 && crossProduct(lower[lower.length - 2], lower[lower.length - 1], point) <= 0) lower.pop();
                lower.push(point);
            }
            const upper = [];
            for (let i = sorted.length - 1; i >= 0; i--) {
                const point = sorted[i];
                while (upper.length >= 2 && crossProduct(upper[upper.length - 2], upper[upper.length - 1], point) <= 0) upper.pop();
                upper.push(point);
            }
            upper.pop();
            lower.pop();
            return lower.concat(upper);
        };

        const isPointInPolygon = (point, vs) => {
            const x = point[0], y = point[1];
            let inside = false;
            for (let i = 0, j = vs.length - 1; i < vs.length; j = i++) {
                const xi = vs[i][0], yi = vs[i][1];
                const xj = vs[j][0], yj = vs[j][1];
                const intersect = ((yi > y) != (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        };

        const getPolygonArea = (points) => {
            let area = 0;
            const n = points.length;
            if (n < 3) return 0;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += points[i][0] * points[j][1];
                area -= points[j][0] * points[i][1];
            }
            return Math.abs(area) / 2.0;
        };

        // --- NEW ALGORITHM: FIND LARGEST VALID SUBSET HULL ---
        const calculateValidTerritory = (ownedBars, unownedBars) => {
            if (ownedBars.length < 3) return { points: ownedBars.map(b => [b.lat, b.lng]), valid: false, area: 0 };

            let currentCandidateSet = [...ownedBars]; // We start with all owned bars
            
            // Loop until valid or too small
            while (currentCandidateSet.length >= 3) {
                const points = currentCandidateSet.map(b => [b.lat, b.lng]);
                const hull = getConvexHull(points);
                
                // Check for intruders (unowned bars inside)
                let intruders = 0;
                for (let bar of unownedBars) {
                    if (isPointInPolygon([bar.lat, bar.lng], hull)) {
                        intruders++;
                    }
                }

                if (intruders === 0) {
                    // Valid!
                    return { points: hull, valid: true, area: getPolygonArea(hull) };
                }

                // Invalid: We must remove a vertex from the hull to try and free the intruder.
                // Heuristic: Try removing each vertex of the current hull and see which result yields the best score.
                // Score = Minimize Intruders (Primary), Maximize Remaining Area (Secondary)
                
                // Identify which bars correspond to hull vertices
                // Since 'hull' points are just coords, we match them back to bars
                // Note: simple matching by lat/lng is sufficient here
                
                let bestSet = null;
                let bestScore = { intruders: Infinity, area: -1 };

                // Map hull points to actual bar objects in candidate set
                const hullBars = currentCandidateSet.filter(b => 
                    hull.some(h => Math.abs(h[0] - b.lat) < 0.000001 && Math.abs(h[1] - b.lng) < 0.000001)
                );

                // If for some reason filtering failed (precision), just try removing all from set (slower but safer)
                const candidatesToRemove = hullBars.length > 0 ? hullBars : currentCandidateSet;

                for (let barToRemove of candidatesToRemove) {
                    const testSet = currentCandidateSet.filter(b => b.id !== barToRemove.id);
                    if (testSet.length < 3) continue;

                    const testPoints = testSet.map(b => [b.lat, b.lng]);
                    const testHull = getConvexHull(testPoints);
                    
                    let testIntruders = 0;
                    for (let bar of unownedBars) {
                        if (isPointInPolygon([bar.lat, bar.lng], testHull)) testIntruders++;
                    }
                    const testArea = getPolygonArea(testHull);

                    // Logic: We want FEWER intruders. If equal intruders, MORE area.
                    if (testIntruders < bestScore.intruders || (testIntruders === bestScore.intruders && testArea > bestScore.area)) {
                        bestScore = { intruders: testIntruders, area: testArea };
                        bestSet = testSet;
                    }
                }

                if (bestSet) {
                    currentCandidateSet = bestSet;
                } else {
                    // Dead end
                    break;
                }
            }
            
            // Fallback if no polygon found
            return { points: [], valid: false, area: 0 };
        };


        // --- DATA: BARS ---
        const INITIAL_BARS = [
            // Neuk√∂lln
            { id: 1, district: "Neuk√∂lln", name: "Das √ñ", lat: 52.4808, lng: 13.4261, baseCost: 100, baseIncome: 1, type: "Kneipe", description: "Urig. Tischkicker. Billiges Bier." },
            { id: 2, district: "Neuk√∂lln", name: "Flunker-Kranich", lat: 52.4825, lng: 13.4330, baseCost: 500, baseIncome: 4, type: "Rooftop", description: "Sonnenuntergang √ºber den Arcaden." },
            { id: 21, district: "Neuk√∂lln", name: "Rixdorf Lounge", lat: 52.4730, lng: 13.4450, baseCost: 750, baseIncome: 6, type: "Lounge", description: "Versteckt im b√∂hmischen Dorf." },
            { id: 22, district: "Neuk√∂lln", name: "Tempelhofer Feld", lat: 52.4720, lng: 13.4150, baseCost: 1500, baseIncome: 12, type: "OpenAir", description: "Bier auf der Landebahn." },

            // Kreuzberg
            { id: 3, district: "Kreuzberg", name: "Club der Illusion√§re", lat: 52.4965, lng: 13.4520, baseCost: 1200, baseIncome: 10, type: "Outdoor", description: "Tanzen am Flutgraben." },
            { id: 4, district: "Kreuzberg", name: "Pink Palace", lat: 52.4975, lng: 13.4185, baseCost: 2500, baseIncome: 25, type: "Kult", description: "Pl√ºschig, pink und legend√§r." },
            { id: 8, district: "Kreuzberg", name: "Floodgate", lat: 52.5008, lng: 13.4445, baseCost: 45000, baseIncome: 350, type: "Club", description: "LED-Decke an der Spree." },
            { id: 11, district: "Kreuzberg", name: "Prince Charles", lat: 52.5036, lng: 13.4077, baseCost: 15000, baseIncome: 120, type: "Club", description: "Hip Hop und Burger im Pool." },
            
            // Friedrichshain
            { id: 9, district: "Friedrichshain", name: "Bergheim", lat: 52.5113, lng: 13.4433, baseCost: 100000, baseIncome: 800, type: "Legend√§r", description: "Die h√§rteste T√ºr der Welt." },
            { id: 12, district: "Friedrichshain", name: "Tante Renate", lat: 52.4976, lng: 13.4658, baseCost: 30000, baseIncome: 210, type: "Club", description: "Ein Haus voller wirrer Partys." },
            { id: 13, district: "Friedrichshain", name: "The Grid", lat: 52.5028, lng: 13.4475, baseCost: 60000, baseIncome: 450, type: "Tourist", description: "Jeder Schulausflug endet hier." },
            { id: 14, district: "Friedrichshain", name: "Star Club", lat: 52.5085, lng: 13.4542, baseCost: 8000, baseIncome: 60, type: "Kultur", description: "Kino, Klettern, Punkrock." },

            // Mitte
            { id: 6, district: "Mitte", name: "Der Safe", lat: 52.5106, lng: 13.4194, baseCost: 10000, baseIncome: 90, type: "Techno", description: "Der Urvater des Berliner Techno." },
            { id: 10, district: "Mitte", name: "KittyKat", lat: 52.5126, lng: 13.4165, baseCost: 250000, baseIncome: 1500, type: "Legend√§r", description: "Hier fallen alle H√ºllen." },
            { id: 15, district: "Mitte", name: "King Kong Bar", lat: 52.5255, lng: 13.4124, baseCost: 3500, baseIncome: 30, type: "Bar", description: "Schick in der Brunnenstra√üe." },
            { id: 16, district: "Mitte", name: "Permament Vacation", lat: 52.5220, lng: 13.3880, baseCost: 7000, baseIncome: 55, type: "Politik", description: "Wo Politiker K√∂lsch trinken." },
            { id: 23, district: "Mitte", name: "TV Tower Bar", lat: 52.5208, lng: 13.4094, baseCost: 20000, baseIncome: 180, type: "View", description: "Ganz oben in der Kugel." },

            // Prenzlauer Berg
            { id: 7, district: "Prenzlauer Berg", name: "Panke Garten", lat: 52.5404, lng: 13.4107, baseCost: 20000, baseIncome: 180, type: "Biergarten", description: "Berlins √§ltester Biergarten." },
            { id: 17, district: "Prenzlauer Berg", name: "Culture Brewery", lat: 52.5390, lng: 13.4132, baseCost: 25000, baseIncome: 190, type: "Areal", description: "Riesiges Areal, viele Clubs." },
            { id: 24, district: "Prenzlauer Berg", name: "Mauerpark Karaoke", lat: 52.5440, lng: 13.4030, baseCost: 2500, baseIncome: 20, type: "OpenAir", description: "Sonntags singen vor tausenden." },
            { id: 25, district: "Prenzlauer Berg", name: "Wasserturm", lat: 52.5330, lng: 13.4200, baseCost: 8000, baseIncome: 65, type: "Kiez", description: "Rund um den Turm." },

            // Charlottenburg / West
            { id: 5, district: "Charlottenburg", name: "Ape Lounge", lat: 52.5053, lng: 13.3364, baseCost: 5000, baseIncome: 45, type: "Chic", description: "Teure Drinks, Blick auf Affen." },
            { id: 18, district: "Charlottenburg", name: "Dunkles Caf√©", lat: 52.5065, lng: 13.3200, baseCost: 4000, baseIncome: 35, type: "24h", description: "Hat eigentlich immer offen." },
            { id: 26, district: "Charlottenburg", name: "Schlossgarten", lat: 52.5200, lng: 13.2950, baseCost: 12000, baseIncome: 95, type: "Royal", description: "Feiern wie ein K√∂nig." },
            { id: 27, district: "Charlottenburg", name: "Ku'damm Beach", lat: 52.4980, lng: 13.2800, baseCost: 30000, baseIncome: 220, type: "Luxus", description: "Champagner am Halensee." },

            // Lichtenberg
            { id: 19, district: "Lichtenberg", name: "Sisyphus Hill", lat: 52.4930, lng: 13.4910, baseCost: 80000, baseIncome: 650, type: "OpenAir", description: "Feiern von Freitag bis Montag." },
            { id: 28, district: "Lichtenberg", name: "Dong Xuan Center", lat: 52.5350, lng: 13.4850, baseCost: 5000, baseIncome: 40, type: "Markt", description: "Geheimtipps in Halle 8." },
            { id: 29, district: "Lichtenberg", name: "Rummels Bucht", lat: 52.4970, lng: 13.4800, baseCost: 18000, baseIncome: 130, type: "Piraten", description: "Versteckt am Ufer." },

            // Treptow
            { id: 20, district: "Treptow", name: "Molecule Man", lat: 52.4967, lng: 13.4593, baseCost: 500000, baseIncome: 2500, type: "Landmark", description: "Party auf dem Wasser." },
            { id: 30, district: "Treptow", name: "Island of Youth", lat: 52.4850, lng: 13.4750, baseCost: 10000, baseIncome: 85, type: "Insel", description: "Abh√§ngen auf der Br√ºcke." },
            { id: 31, district: "Treptow", name: "Arena Badeschiff", lat: 52.5000, lng: 13.4530, baseCost: 60000, baseIncome: 420, type: "Sommer", description: "Pool in der Spree." }
        ];

        const DISTRICT_POLYGONS = {
            "Neuk√∂lln": [[52.495, 13.419], [52.485, 13.450], [52.470, 13.460], [52.440, 13.460], [52.420, 13.440], [52.440, 13.410], [52.470, 13.420]],
            "Kreuzberg": [[52.505, 13.375], [52.508, 13.400], [52.500, 13.450], [52.495, 13.450], [52.490, 13.420], [52.485, 13.380], [52.495, 13.370]],
            "Friedrichshain": [[52.525, 13.435], [52.525, 13.465], [52.510, 13.480], [52.500, 13.475], [52.495, 13.455], [52.500, 13.435], [52.515, 13.425]],
            "Mitte": [[52.535, 13.365], [52.535, 13.410], [52.525, 13.425], [52.510, 13.425], [52.505, 13.400], [52.505, 13.365], [52.520, 13.350]],
            "Prenzlauer Berg": [[52.555, 13.390], [52.560, 13.435], [52.550, 13.460], [52.525, 13.460], [52.525, 13.420], [52.530, 13.400]],
            "Charlottenburg": [[52.525, 13.260], [52.525, 13.330], [52.515, 13.350], [52.500, 13.350], [52.495, 13.300], [52.495, 13.250]],
            "Lichtenberg": [[52.540, 13.475], [52.540, 13.520], [52.500, 13.530], [52.480, 13.520], [52.480, 13.480], [52.500, 13.470]],
            "Treptow": [[52.495, 13.455], [52.495, 13.500], [52.460, 13.520], [52.440, 13.500], [52.460, 13.450]]
        };

        const BASE_ACHIEVEMENTS = [
            { id: 'first_buck', name: 'Erster Euro', description: 'Besitze 1‚Ç¨', condition: (state) => state.money >= 1, reward: 0 },
            { id: 'bar_owner', name: 'Kneipier', description: 'Kaufe deine erste Bar', condition: (state, bars) => Object.values(bars).some(b => b.owned), reward: 1.1 },
            { id: 'millionaire', name: 'Million√§r', description: 'Besitze 1.000.000‚Ç¨', condition: (state) => state.money >= 1000000, reward: 1.5 },
            { id: 'bottle_master', name: 'Pfand Profi', description: 'Erreiche Sammel-Level 5', condition: (state) => state.clickLevel >= 5, reward: 1.2 },
            { id: 'click_100', name: 'Finger-Training', description: 'Klicke 100 mal', condition: (state) => state.totalClicks >= 100, reward: 1.1 },
            { id: 'click_500', name: 'Maus-Zerst√∂rer', description: 'Klicke 500 mal', condition: (state) => state.totalClicks >= 500, reward: 1.2 },
            { id: 'click_1000', name: 'Lichtgeschwindigkeit', description: 'Klicke 1000 mal', condition: (state) => state.totalClicks >= 1000, reward: 1.3 },
        ];

        const DISTRICT_ACHIEVEMENTS = Object.keys(DISTRICT_POLYGONS).map(districtName => ({
            id: `king_${districtName.toLowerCase().replace(/\s/g, '_')}`,
            name: `King of ${districtName}`,
            description: `Besitze alle Bars in ${districtName}`,
            districtTarget: districtName,
            condition: (state, bars) => {
                const districtBars = INITIAL_BARS.filter(b => b.district === districtName);
                if (districtBars.length === 0) return false;
                return districtBars.every(b => bars[b.id] && bars[b.id].owned);
            },
            reward: 1.25 
        }));

        const ALL_ACHIEVEMENTS = [...BASE_ACHIEVEMENTS, ...DISTRICT_ACHIEVEMENTS];

        // Helpers
        const formatMoney = (amount) => {
            if (amount >= 1000000) return (amount / 1000000).toFixed(2).replace('.', ',') + ' Mio. ‚Ç¨';
            if (amount >= 1000) return (amount / 1000).toFixed(1).replace('.', ',') + 'k ‚Ç¨';
            return new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR', maximumFractionDigits: 0 }).format(amount);
        };

        const formatShortMoney = (amount) => {
             if (amount >= 1000000) return (amount / 1000000).toFixed(1) + 'M';
             if (amount >= 1000) return (amount / 1000).toFixed(1) + 'k';
             return Math.floor(amount);
        }

        const App = () => {
            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem('berlinBarTycoon_v7');
                const defaultState = {
                    money: 0,
                    clickLevel: 1,
                    totalClicks: 0,
                    unlockedAchievements: [],
                    bars: {},
                    hasSeenWin: false
                };
                INITIAL_BARS.forEach(bar => { defaultState.bars[bar.id] = { level: 0, owned: false }; });

                if (saved) {
                    const parsed = JSON.parse(saved);
                    const mergedBars = { ...defaultState.bars, ...(parsed.bars || {}) };
                    return { ...defaultState, ...parsed, bars: mergedBars };
                }
                return defaultState;
            });

            // Territory State
            const [territoryState, setTerritoryState] = useState({ points: [], bonus: 1.0 });

            const [selectedBarId, setSelectedBarId] = useState(null);
            const [isListOpen, setIsListOpen] = useState(false);
            const [showAchievements, setShowAchievements] = useState(false);
            const [showWinModal, setShowWinModal] = useState(false);
            const [notification, setNotification] = useState(null);
            
            const mapRef = useRef(null);
            const markersRef = useRef({});
            const polygonsRef = useRef({});
            const territoryLayerRef = useRef(null);

            // --- CALCULATIONS ---
            const getGlobalMultiplier = () => {
                let multiplier = 1;
                gameState.unlockedAchievements.forEach(achId => {
                    const ach = ALL_ACHIEVEMENTS.find(a => a.id === achId);
                    if (ach && ach.reward > 0) multiplier *= ach.reward;
                });
                multiplier *= territoryState.bonus;
                return multiplier;
            };

            const globalMult = useMemo(() => getGlobalMultiplier(), [gameState.unlockedAchievements, territoryState.bonus]);

            const getIncome = (barId) => {
                const bar = INITIAL_BARS.find(b => b.id === barId);
                const state = gameState.bars[barId];
                if (!state || !state.owned) return 0;
                const milestonesPassed = Math.floor(state.level / 5);
                return bar.baseIncome * state.level * globalMult * Math.pow(2, milestonesPassed);
            };

            const getTotalIncome = () => {
                return INITIAL_BARS.reduce((sum, bar) => sum + getIncome(bar.id), 0);
            };

            const getUpgradeCost = (barId) => {
                const bar = INITIAL_BARS.find(b => b.id === barId);
                const state = gameState.bars[barId];
                if (!state || !state.owned) return bar.baseCost;
                return Math.floor(bar.baseCost * Math.pow(1.5, state.level));
            };

            const getClickIncome = () => {
                const base = (10 * Math.pow(1.8, gameState.clickLevel - 1)) + (getTotalIncome() * 0.05);
                return base * globalMult * 4; // Double of previous double (x4 total now to satisfy "Verdopple den klick bonus")
            };

            const getClickUpgradeCost = () => {
                return Math.floor(500 * Math.pow(2.5, gameState.clickLevel - 1));
            };

            const canAffordAnyUpgrade = useMemo(() => {
                return INITIAL_BARS.some(bar => gameState.money >= getUpgradeCost(bar.id));
            }, [gameState.money, gameState.bars]);

            // --- LOOPS & EFFECTS ---
            
            // Territory Logic - Largest Valid Hull
            useEffect(() => {
                const allOwnedBars = INITIAL_BARS.filter(b => gameState.bars[b.id]?.owned);
                const unownedBars = INITIAL_BARS.filter(b => !gameState.bars[b.id]?.owned);
                
                const result = calculateValidTerritory(allOwnedBars, unownedBars);
                
                if (result.valid) {
                    const bonusFactor = 1 + (result.area * 200); 
                    setTerritoryState({
                        points: result.points,
                        bonus: Math.max(1, bonusFactor)
                    });
                } else if (allOwnedBars.length === 2) {
                    // Fallback line for 2 points (no area bonus)
                    setTerritoryState({ points: allOwnedBars.map(b => [b.lat, b.lng]), bonus: 1.0 });
                }
            }, [gameState.bars]);

            // Game Loop
            useEffect(() => {
                const interval = setInterval(() => {
                    const income = getTotalIncome();
                    if (income > 0) setGameState(prev => ({ ...prev, money: prev.money + income }));
                }, 1000);
                return () => clearInterval(interval);
            }, [gameState.bars, gameState.unlockedAchievements, territoryState.bonus]);

            // Save
            useEffect(() => {
                localStorage.setItem('berlinBarTycoon_v7', JSON.stringify(gameState));
            }, [gameState]);

            useEffect(() => {
                if (gameState.money >= 1000000 && !gameState.hasSeenWin) {
                    setShowWinModal(true);
                    setGameState(prev => ({ ...prev, hasSeenWin: true }));
                }
            }, [gameState.money]);

            // Achievements
            useEffect(() => {
                const newUnlocks = [];
                ALL_ACHIEVEMENTS.forEach(ach => {
                    if (!gameState.unlockedAchievements.includes(ach.id)) {
                        if (ach.condition(gameState, gameState.bars)) {
                            newUnlocks.push(ach);
                        }
                    }
                });

                if (newUnlocks.length > 0) {
                    setGameState(prev => ({
                        ...prev,
                        unlockedAchievements: [...prev.unlockedAchievements, ...newUnlocks.map(u => u.id)]
                    }));
                    setNotification({
                        title: "üèÜ Erfolg freigeschaltet!",
                        message: `${newUnlocks[0].name}: ${newUnlocks[0].description}`
                    });
                    setTimeout(() => setNotification(null), 4000);
                }
            }, [gameState.money, gameState.bars, gameState.clickLevel, gameState.totalClicks]);

            // Particles
            useEffect(() => {
                 const particleInterval = setInterval(() => {
                    const ownedBars = INITIAL_BARS.filter(b => gameState.bars[b.id]?.owned);
                    if (ownedBars.length > 0) {
                        const randomBar = ownedBars[Math.floor(Math.random() * ownedBars.length)];
                        showMoneyParticle(randomBar.id);
                    }
                }, 2000);
                return () => clearInterval(particleInterval);
            }, [gameState.bars]);


            // --- ACTIONS ---
            const handleClicker = () => {
                setGameState(prev => ({ 
                    ...prev, 
                    money: prev.money + getClickIncome(),
                    totalClicks: (prev.totalClicks || 0) + 1 
                }));
            };

            const upgradeClicker = () => {
                const cost = getClickUpgradeCost();
                if (gameState.money >= cost) setGameState(prev => ({ ...prev, money: prev.money - cost, clickLevel: prev.clickLevel + 1 }));
            };

            window.triggerUpgrade = (barId, event) => {
                if(event) event.stopPropagation();
                purchaseOrUpgradeBar(barId, true);
            };

            const purchaseOrUpgradeBar = (barId, fromMap = false) => {
                setGameState(prev => {
                    const bar = INITIAL_BARS.find(b => b.id === barId);
                    const state = prev.bars[barId];
                    const currentLevel = state ? state.level : 0;
                    const isOwned = state ? state.owned : false;
                    const cost = !isOwned ? bar.baseCost : Math.floor(bar.baseCost * Math.pow(1.5, currentLevel));
                    
                    if (prev.money >= cost) {
                        if (fromMap) {
                            showFloatingText(bar.id, isOwned ? `Lvl ${currentLevel + 1}` : "Gekauft!");
                        }
                        const newState = { ...prev, money: prev.money - cost, bars: { ...prev.bars } };
                        newState.bars[barId] = { ...prev.bars[barId] };
                        if (!newState.bars[barId].owned) {
                            newState.bars[barId].owned = true;
                            newState.bars[barId].level = 1;
                        } else {
                            newState.bars[barId].level += 1;
                        }
                        return newState;
                    }
                    return prev;
                });
            };

            const upgradeAll = () => {
                setGameState(prev => {
                    let currentMoney = prev.money;
                    const newBars = { ...prev.bars };
                    let changed = false;
                    
                    INITIAL_BARS.forEach(bar => {
                        const state = newBars[bar.id];
                        const cost = !state.owned ? bar.baseCost : Math.floor(bar.baseCost * Math.pow(1.5, state.level));
                        
                        if (currentMoney >= cost) {
                            currentMoney -= cost;
                            newBars[bar.id] = { ...state };
                            if (!state.owned) {
                                newBars[bar.id].owned = true;
                                newBars[bar.id].level = 1;
                            } else {
                                newBars[bar.id].level += 1;
                            }
                            changed = true;
                        }
                    });

                    if (changed) {
                        return { ...prev, money: currentMoney, bars: newBars };
                    }
                    return prev;
                });
            };

            const showFloatingText = (barId, text) => {
                const marker = markersRef.current[barId];
                if (!marker) return;
                const map = mapRef.current;
                const bar = INITIAL_BARS.find(b => b.id === barId);
                const point = map.latLngToContainerPoint([bar.lat, bar.lng]);
                const el = document.createElement('div');
                el.className = 'float-text';
                el.innerText = text;
                el.style.left = point.x + 'px';
                el.style.top = point.y + 'px';
                document.getElementById('map').appendChild(el);
                setTimeout(() => el.remove(), 1000);
            };

             const showMoneyParticle = (barId) => {
                const marker = markersRef.current[barId];
                if (!marker || !mapRef.current) return;
                const map = mapRef.current;
                const bar = INITIAL_BARS.find(b => b.id === barId);
                const point = map.latLngToContainerPoint([bar.lat, bar.lng]);
                const el = document.createElement('div');
                el.className = 'money-particle';
                el.innerText = '‚Ç¨';
                el.style.left = (point.x + (Math.random() * 20 - 10)) + 'px';
                el.style.top = point.y + 'px';
                document.getElementById('map').appendChild(el);
                setTimeout(() => el.remove(), 4000);
            };

            // --- MAP DRAWING ---
            useEffect(() => {
                if (!mapRef.current) {
                    mapRef.current = L.map('map', { zoomControl: false, attributionControl: false }).setView([52.51, 13.40], 12);
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 19
                    }).addTo(mapRef.current);
                }

                // 1. Background Districts
                Object.keys(DISTRICT_POLYGONS).forEach(districtName => {
                    const coords = DISTRICT_POLYGONS[districtName];
                    const barsInDistrict = INITIAL_BARS.filter(b => b.district === districtName);
                    const isComplete = barsInDistrict.length > 0 && barsInDistrict.every(b => gameState.bars[b.id]?.owned);
                    const style = isComplete ? { color: '#ffd700', weight: 2, opacity: 0.8, fillColor: '#ffd700', fillOpacity: 0.2 } 
                                             : { color: '#4b5563', weight: 1, opacity: 0.5, fillColor: '#000000', fillOpacity: 0.0 };

                    if (!polygonsRef.current[districtName]) {
                        const polygon = L.polygon(coords, style).addTo(mapRef.current);
                        polygon.bringToBack();
                        polygonsRef.current[districtName] = polygon;
                    } else {
                        polygonsRef.current[districtName].setStyle(style);
                    }
                });
                
                // 2. Territory Hull (Safe Subset)
                if (territoryLayerRef.current) territoryLayerRef.current.remove();
                
                if (territoryState.points.length >= 3) {
                    territoryLayerRef.current = L.polygon(territoryState.points, {
                        color: '#22c55e', weight: 3, opacity: 0.8,
                        fillOpacity: 0.15, fillColor: '#22c55e',
                        dashArray: null, lineJoin: 'round'
                    }).addTo(mapRef.current);
                } else if (territoryState.points.length === 2) {
                    territoryLayerRef.current = L.polyline(territoryState.points, {
                        color: '#22c55e', weight: 2, opacity: 0.8, dashArray: '5, 10'
                    }).addTo(mapRef.current);
                }

                // 3. Markers
                INITIAL_BARS.forEach(bar => {
                    const state = gameState.bars[bar.id] || { owned: false };
                    const cost = getUpgradeCost(bar.id);
                    const isAffordable = gameState.money >= cost;
                    const income = getIncome(bar.id);
                    
                    let markerClass = 'bar-marker';
                    if (state.owned) markerClass += ' marker-owned';
                    else if (isAffordable) markerClass += ' marker-affordable-base';
                    else markerClass += ' marker-locked';

                    let levelBadgeHtml = '';
                    if (state.owned && state.level > 0) {
                        let badgeClass = 'level-badge';
                        if (state.level >= 25) badgeClass += ' level-tier-3';
                        else if (state.level >= 10) badgeClass += ' level-tier-2';
                        else if (state.level >= 5) badgeClass += ' level-tier-1';
                        levelBadgeHtml = `<div class="${badgeClass}">${state.level}</div>`;
                    }

                    const arrowHtml = isAffordable 
                        ? `<div class="upgrade-arrow" onclick="window.triggerUpgrade(${bar.id}, event)" title="Direkt kaufen/upgraden">‚¨ÜÔ∏è</div>` : '';

                    const iconHtml = `
                        <div class="bar-marker-container">
                            ${arrowHtml}
                            <div class="${markerClass}">${state.owned ? 'üçª' : 'üîí'}</div>
                            ${levelBadgeHtml}
                            ${state.owned && income > 0 ? `<div class="income-badge">${formatShortMoney(income)}/s</div>` : ''}
                        </div>
                    `;

                    const customIcon = L.divIcon({ className: 'custom-leaflet-icon', html: iconHtml, iconSize: [30, 30], iconAnchor: [15, 15] });

                    if (!markersRef.current[bar.id]) {
                        const marker = L.marker([bar.lat, bar.lng], { icon: customIcon })
                            .addTo(mapRef.current)
                            .on('click', () => {
                                setSelectedBarId(bar.id);
                                mapRef.current.setView([bar.lat + 0.005, bar.lng], 14);
                                setIsListOpen(false);
                            });
                        markersRef.current[bar.id] = marker;
                    } else {
                        markersRef.current[bar.id].setIcon(customIcon);
                        if (isAffordable) markersRef.current[bar.id].setZIndexOffset(1000);
                        else markersRef.current[bar.id].setZIndexOffset(0);
                    }
                });
            }, [gameState.bars, gameState.money, territoryState]);

            const barsByDistrict = useMemo(() => {
                const groups = {};
                INITIAL_BARS.forEach(bar => {
                    if (!groups[bar.district]) groups[bar.district] = [];
                    groups[bar.district].push(bar);
                });
                return groups;
            }, []);

            const selectedBar = selectedBarId ? INITIAL_BARS.find(b => b.id === selectedBarId) : null;
            const selectedBarState = selectedBarId ? gameState.bars[selectedBarId] : null;

            return (
                <div className="relative h-screen w-screen font-sans text-white select-none">
                    <div id="map" className="absolute top-0 left-0 w-full h-full"></div>

                    {showWinModal && (
                        <div className="absolute inset-0 z-50 bg-black/80 flex items-center justify-center p-4" onClick={() => setShowWinModal(false)}>
                            <div className="absolute inset-0 overflow-hidden pointer-events-none">
                                {[...Array(50)].map((_, i) => (
                                    <div key={i} className="confetti-piece" style={{ left: `${Math.random() * 100}%`, animationDelay: `${Math.random() * 2}s`, backgroundColor: ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f'][Math.floor(Math.random() * 6)] }}></div>
                                ))}
                            </div>
                            <div className="bg-gray-900 border-4 border-yellow-500 rounded-3xl p-8 text-center shadow-2xl animate-fade-in max-w-lg z-50">
                                <h1 className="text-4xl md:text-6xl font-black text-yellow-500 mb-4 drop-shadow-lg">BERLIN<br/>BAR K√ñNIG!</h1>
                                <p className="text-xl text-gray-300 mb-6">Du hast deine erste Million gemacht!<br/>Die Stadt liegt dir zu F√º√üen.</p>
                                <div className="text-6xl mb-6">üëë</div>
                                <button onClick={(e) => { e.stopPropagation(); setShowWinModal(false); }} className="bg-yellow-600 hover:bg-yellow-500 text-black font-bold text-xl px-8 py-3 rounded-full transition-transform hover:scale-105">Weiterfeiern</button>
                            </div>
                        </div>
                    )}

                    {notification && (
                        <div className="absolute top-24 left-1/2 transform -translate-x-1/2 z-50 bg-yellow-600 text-white px-6 py-3 rounded-full shadow-2xl flex items-center gap-3 animate-fade-in border-2 border-yellow-400 w-max max-w-[90vw]">
                            <i data-lucide="trophy" className="w-6 h-6 flex-shrink-0"></i>
                            <div>
                                <div className="font-bold text-sm">{notification.title}</div>
                                <div className="text-xs">{notification.message}</div>
                            </div>
                        </div>
                    )}

                    {/* HUD */}
                    <div className="absolute top-0 left-0 w-full p-4 z-20 pointer-events-none flex justify-between items-start">
                        <div className="flex flex-col gap-2 pointer-events-auto">
                            <div className="bg-gray-900/90 backdrop-blur border border-gray-700 p-4 rounded-xl shadow-2xl min-w-[180px]">
                                <div className="text-gray-400 text-xs uppercase tracking-wider font-bold">Kontostand</div>
                                <div className="text-3xl font-bold text-green-400">{formatMoney(gameState.money)}</div>
                                <div className="text-sm text-gray-300 flex items-center gap-1">
                                    <i data-lucide="trending-up" className="w-4 h-4"></i> 
                                    {formatMoney(getTotalIncome())} / Sek.
                                </div>
                                <div className="flex flex-col gap-0.5 mt-1">
                                    {globalMult > 1 && <div className="text-xs text-yellow-500 font-bold">Multiplikator: x{globalMult.toFixed(2)}</div>}
                                    {territoryState.bonus > 1 && <div className="text-[10px] text-green-400">davon Fl√§che: x{territoryState.bonus.toFixed(2)}</div>}
                                </div>
                            </div>
                            
                            <div className="flex gap-2">
                                <button onClick={() => setIsListOpen(!isListOpen)} className="bg-gray-800 border border-gray-600 text-white p-3 rounded-xl shadow-lg hover:bg-gray-700 active:scale-95 transition-transform flex items-center gap-2">
                                    <span>üìã</span><span className="font-bold text-sm hidden md:inline">{isListOpen ? 'Zu' : 'Liste'}</span>
                                </button>
                                <button onClick={() => setShowAchievements(!showAchievements)} className="bg-gray-800 border border-gray-600 text-white p-3 rounded-xl shadow-lg hover:bg-gray-700 active:scale-95 transition-transform flex items-center gap-2 relative">
                                    <span>üèÜ</span>
                                    {gameState.unlockedAchievements.length > 0 && <span className="absolute -top-1 -right-1 bg-yellow-500 text-black text-[10px] w-5 h-5 rounded-full flex items-center justify-center font-bold">{gameState.unlockedAchievements.length}</span>}
                                </button>
                                
                                <button onClick={upgradeAll} disabled={!canAffordAnyUpgrade} className={`p-3 rounded-xl shadow-lg flex items-center gap-2 transition-transform border ${canAffordAnyUpgrade ? 'bg-blue-600 border-blue-400 hover:bg-blue-500 text-white active:scale-95' : 'bg-gray-800 border-gray-600 text-gray-500 opacity-50 cursor-not-allowed'}`} title="Alles upgraden was m√∂glich ist">
                                    <span className="font-bold">‚ö° Alles</span>
                                </button>
                            </div>
                        </div>

                        <div className="flex flex-col items-end gap-2 pointer-events-auto">
                            <button onClick={handleClicker} className="bg-yellow-500 hover:bg-yellow-400 text-black font-bold p-4 md:p-6 rounded-full shadow-lg transform hover:scale-105 active:scale-95 transition-all border-4 border-yellow-600 group relative overflow-hidden">
                                <div className="flex flex-col items-center relative z-10">
                                    <span className="text-2xl md:text-3xl group-active:animate-bounce">üçæ</span>
                                    <div className="text-xs font-bold mt-1 bg-black/40 px-2 rounded-full border border-yellow-300/30">
                                        +{formatShortMoney(getClickIncome())}
                                    </div>
                                </div>
                                <div className="absolute bottom-0 left-0 w-full h-1 bg-black/20"></div>
                            </button>
                            <button onClick={upgradeClicker} disabled={gameState.money < getClickUpgradeCost()} className={`text-xs font-bold px-3 py-1.5 rounded-lg border flex items-center gap-2 transition-colors ${gameState.money >= getClickUpgradeCost() ? 'bg-blue-600 border-blue-400 hover:bg-blue-500 text-white' : 'bg-gray-800 border-gray-600 text-gray-500 cursor-not-allowed'}`}>
                                <div className="flex flex-col items-end">
                                    <span>Lvl {gameState.clickLevel}</span>
                                    <span>{formatMoney(getClickUpgradeCost())}</span>
                                </div>
                                <span className="text-lg">‚¨ÜÔ∏è</span>
                            </button>
                        </div>
                    </div>

                    {showAchievements && (
                        <div className="absolute inset-0 z-40 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4" onClick={() => setShowAchievements(false)}>
                            <div className="bg-gray-900 border border-gray-600 rounded-2xl w-full max-w-lg max-h-[80vh] overflow-hidden flex flex-col shadow-2xl" onClick={e => e.stopPropagation()}>
                                <div className="p-4 border-b border-gray-700 flex justify-between items-center bg-gray-800">
                                    <h2 className="text-xl font-bold text-yellow-500 flex items-center gap-2">üèÜ Erfolge</h2>
                                    <button onClick={() => setShowAchievements(false)} className="text-gray-400 hover:text-white">‚úï</button>
                                </div>
                                <div className="p-4 overflow-y-auto space-y-3">
                                    {ALL_ACHIEVEMENTS.map(ach => {
                                        const unlocked = gameState.unlockedAchievements.includes(ach.id);
                                        return (
                                            <div key={ach.id} className={`p-3 rounded-xl border flex items-center gap-3 ${unlocked ? 'bg-gray-800 border-yellow-600/50' : 'bg-gray-900/50 border-gray-800 opacity-60'}`}>
                                                <div className={`w-12 h-12 rounded-full flex items-center justify-center text-2xl ${unlocked ? 'bg-yellow-600 text-white' : 'bg-gray-800 text-gray-600'}`}>
                                                    {unlocked ? '‚úì' : '?'}
                                                </div>
                                                <div className="flex-1">
                                                    <div className={`font-bold ${unlocked ? 'text-white' : 'text-gray-500'}`}>{ach.name}</div>
                                                    <div className="text-xs text-gray-400">{ach.description}</div>
                                                </div>
                                                {ach.reward > 0 && <div className="text-xs font-mono text-green-400 bg-green-900/30 px-2 py-1 rounded">x{ach.reward} Boost</div>}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    )}

                    {selectedBar && (
                        <div className="absolute bottom-0 left-0 right-0 md:left-auto md:right-4 md:bottom-4 md:w-96 md:top-24 z-30 p-4 animate-slide-up pointer-events-none md:pointer-events-auto">
                            <div className="bg-gray-900/95 backdrop-blur border border-gray-700 rounded-xl p-6 text-white shadow-2xl relative pointer-events-auto">
                                <button onClick={() => setSelectedBarId(null)} className="absolute top-2 right-2 text-gray-400 hover:text-white p-2">‚úï</button>
                                <div className="flex items-center gap-3 mb-4">
                                    <div className={`w-12 h-12 rounded-full flex items-center justify-center text-2xl ${selectedBarState.owned ? 'bg-green-600' : 'bg-red-600'}`}>
                                        {selectedBarState.owned ? 'üè¢' : 'üîí'}
                                    </div>
                                    <div>
                                        <div className="text-[10px] text-yellow-500 uppercase font-bold tracking-widest">{selectedBar.district}</div>
                                        <h2 className="text-xl font-bold leading-tight">{selectedBar.name}</h2>
                                        <div className="text-xs text-gray-400 bg-gray-800 px-2 py-0.5 rounded inline-block mt-1">{selectedBar.type}</div>
                                    </div>
                                </div>
                                <p className="text-sm text-gray-300 mb-6 italic border-l-2 border-gray-600 pl-3">"{selectedBar.description}"</p>
                                <div className="grid grid-cols-2 gap-4 mb-6">
                                    <div className="bg-gray-800 p-3 rounded-lg">
                                        <div className="text-xs text-gray-500">Level</div>
                                        <div className="text-xl font-bold text-white flex items-center gap-2">
                                            {selectedBarState.level} 
                                            <span className="text-[10px] bg-yellow-600 text-white px-1.5 py-0.5 rounded">
                                                x{Math.pow(2, Math.floor(selectedBarState.level / 5))} Boost
                                            </span>
                                        </div>
                                    </div>
                                    <div className="bg-gray-800 p-3 rounded-lg">
                                        <div className="text-xs text-gray-500">Einkommen</div>
                                        <div className="text-xl font-bold text-green-400">{formatMoney(getIncome(selectedBar.id))}<span className="text-xs text-gray-500">/s</span></div>
                                    </div>
                                </div>
                                <button onClick={() => purchaseOrUpgradeBar(selectedBar.id)} disabled={gameState.money < getUpgradeCost(selectedBar.id)} className={`w-full py-4 rounded-lg font-bold text-lg transition-all flex justify-between px-6 items-center ${gameState.money >= getUpgradeCost(selectedBar.id) ? 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg shadow-blue-900/50' : 'bg-gray-700 text-gray-500 cursor-not-allowed'}`}>
                                    <span>{selectedBarState.owned ? "Ausbauen" : "Kaufen"}</span>
                                    <span>{formatMoney(getUpgradeCost(selectedBar.id))}</span>
                                </button>
                                <div className="mt-2 text-center text-xs text-gray-500">N√§chster x2 Boost bei Level {Math.ceil((selectedBarState.level + 1) / 5) * 5}</div>
                            </div>
                        </div>
                    )}

                    <div className={`absolute top-24 left-4 z-20 transition-all duration-300 ${isListOpen ? 'opacity-100 translate-x-0' : 'opacity-0 -translate-x-full pointer-events-none'}`}>
                        <div className="bg-gray-900/90 backdrop-blur border border-gray-700 rounded-xl overflow-hidden shadow-xl w-72 max-h-[70vh] flex flex-col pointer-events-auto">
                            <div className="p-3 border-b border-gray-700 bg-gray-800/50 font-bold text-sm text-gray-300 flex justify-between items-center">
                                <span>Alle Locations</span>
                                <button onClick={() => setIsListOpen(false)} className="text-gray-400 hover:text-white">‚úï</button>
                            </div>
                            <div className="overflow-y-auto flex-1 p-2 space-y-4">
                                {Object.keys(barsByDistrict).sort().map(district => (
                                    <div key={district}>
                                        <div className="text-xs font-bold text-yellow-500 uppercase tracking-widest px-2 mb-1 opacity-70 sticky top-0 bg-gray-900/80 backdrop-blur py-1 z-10">{district}</div>
                                        <div className="space-y-1">
                                            {barsByDistrict[district].map(bar => {
                                                const state = gameState.bars[bar.id] || { owned: false };
                                                const canAfford = gameState.money >= getUpgradeCost(bar.id);
                                                return (
                                                    <div key={bar.id} onClick={() => { setSelectedBarId(bar.id); mapRef.current.setView([bar.lat, bar.lng], 14); if (window.innerWidth < 1024) setIsListOpen(false); }} className={`p-2 rounded cursor-pointer transition-colors border-l-4 ${state.owned ? 'border-green-500 bg-gray-800/50 hover:bg-gray-700' : 'border-red-900 bg-gray-900/30 hover:bg-gray-800'} ${selectedBarId === bar.id ? 'bg-gray-700' : ''}`}>
                                                        <div className="flex justify-between items-center">
                                                            <div className="flex items-center gap-2 overflow-hidden">{canAfford && <span className="text-[10px] animate-bounce">‚¨ÜÔ∏è</span>}<span className="font-medium text-sm truncate">{bar.name}</span></div>
                                                            {state.owned && <span className="text-[10px] bg-green-900 text-green-300 px-1.5 rounded">Lvl {state.level}</span>}
                                                        </div>
                                                        {!state.owned && <div className="text-[10px] text-gray-500 mt-1">Kosten: {formatMoney(bar.baseCost)}</div>}
                                                    </div>
                                                )
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
